DOING:
* Still need to write code that actually loops the video when its state changes to ended.
*Clicking the screen in fullscreen mode should toggle the controls on. If you click and toggle them on, they can't be toggled off by anything but moving the mouse out of the controls.

* Set up other youtube functions (captions, etc)
    ** Loop button so it can loop
        *** First should set a bool to true so when the video state changes to "ENDED," we set the universal time to 0 and then change the universal state to PLAYING. Boom. Loop.
        *** Don't think I should let youtube's player handle the looping.
    ** Set up the buffering bar using the getPlayerLoadedFraction() function
    ** Make it save all the options in a cookie, so when you reload the page you're good to go.
* Load player from JS--not on the index.html page. Gives us so much more ability to do things when the video first loads. Can't just move the script tag in the html down below our other scrips, because they expect player to be a thing. Then again a lot of that code is in the document.onReadystate stuff, which runs after the page is already loaded, including the JS in the html.
* Catch the play/pause events from users clicking on the player
    **This still has to be considered for mobile probably. Not sure if pointer-events:none works on mobile.
* Consider what to do about buffering. I guess just ignore it? It's kinda handled by the time buffer and everything.
    ** Probably if it's buffering, the client shouldn't ping the video state, because we kinda need to wait until it's done.
    ** in the onplayerstatechange callback, check if the event triggered is buffering. If so, set our state to buffering. If the event is not buffering, check if our state is buffering--if so, set our state to whatever the event is. This way, we only take the state this callback gives us if we were just buffering; otherwise we ignore it.
* Now just have to test everything thoroughly. All features.
* If they're working well enough, we have to implement code to remove the user's ability to press the player and make stuff happen. It'll screw everything up.
* Big scary thing is how much the youtube API is still checking for me. Like after it seeks, even though it was just playing, it might pause locally. That would not trigger an event on the server. Theoretically, if I seek while playing, the server remembers we were just playing, and when I'm done seeking, it sets me back to playing no matter what. But if I'm still buffering and the server tries to make me play, youtube API might reject the playVideo() call and leave me buffering. What then? I'm left to my fate, because my clientYTPlayer.currentState is still == PLAYING, but I'm not playing.
* Make play button replay hte video if state is ended. 

TODO:
* Generally to set up the youtube playing functionality:
    ** Pressing play should play the videos of the other users
    ** Pressing pause should pause the videos of the other users
    ** Scrubbing should work.
    ** Searching
    ** Changing play speed.
    ** All other minor functions.
* Volume settings/mute button
* Fix it so youtube iframe is generated from js, not on the page.
* REFACTOR/CLEAN UP CODE/ORGANIZE FOLDERS

* Ultimately wrap the youtube div in another div, and create your own controls. That way when the user wants to watch a vid from another site, you just fill that div with their video player.


* Stretch goal: Let users paste embed codes of any video player <iframe>, then play it in our video container div.
* Write code that tries to play a video on any site by seeking out the most common tags that hold videos. Maybe grab the mp4 links directly and load those up into a video tag? The code should try as many tactics as possible until it succeeds. Maybe even have a way to ask the viewer "Is this the video? If no, we'll try to find it in the link again. Is this the video?" This requires web scraping.
* Write

===
* Add private messaging functionality
    ** Have to create tabs within the webpage, one for each chat that's open (general, privatechat1, privatechat2, etc). The tabs exist above the chat. In private chats, the serverlist lists everyone included in the private chat.
* Add the ability to @ someone. (I have implemented very rudimentary code for this.)
* Once all above is instituted, do refactoring. Clean up the code. Once that's done, make simultaneous youtube videos work. Once that's done, set up the database. Once that's done, do the frontend so it looks nice using just css and html5 animations etc.

REFACTORING:

* Put the join-room-button code in the actual index.html, in a script in the head, so it runs before the rest of the page loads; otherwise people are able to click on things before the overlay loads to block mouse events.
* Split chat code and video code into separate JS files
* Get rid of clientYTPlayer util class and have literal instantiated objects. Use polymorphism to handle different video types (as in, youtube vs not youtube)
* Remove Jquery
* Write a clientytplayer function that is passed a state and sets current state to that, previous state to whatever it was before, as well as makes 
* In IsNameAvailable(), change the for loop to something cleaner.
* Set up something similar to: https://stackoverflow.com/questions/36327702/nodejs-express-getting-error-as-referenceerror-bodyparser-is-not-defined

THOUGHTS:

* When done with this whole list, refactor the code before proceeding with the next phase of development.
* This will ultimately be a watch2gether clone. I think it's possible to do by having the client catch when the user changes the time on the embeded video, then send that new set time to the server, then send that to the other viewers' clients.
* Add error handling. For example, currently (11/8/20), if your name for some reason is never released after you choose a new one, the code has no way of recognizing that issue. That's a serious issue because the name can never be used again, even by you.
* Could make it so it stores the status of videos. So when you put in a new video, you can press a "back" button that reverts to the previous video at the time that it was at.

~~~~~~~~~~~
===========
~~~~~~~~~~~

DONE:

12/7/20
    ** Full screen controls that show up at the bottom of the screen and drop down after x amount of time
    ** Playback rate
        *** Just check in align server state if the playback rate is different from the server's. If so, adjust ours. When you adjust playback rate, set it on the server with sendstate.
* Set it so if you click the playbackrate button while in fullscreen, it just toggles to the next value up or down. Either do that, or add fastforward and rewind buttons on either side of the playbackrate, and disable playbackrate while inFullScreen is true.
* Catch the esc keypress and check if inFullScreen is true. If so, set it to false.
* Video controls now appear in full screen mode, godfuckingdammit. TOOK. HOURS. Even watch2gether doesn't do that

====
12/6/20

*We're setting playbackrate on our end. Now we just need to set it to the universal value in the server, and then in alignwithstate adjust playbackrate to match the server's.
* Also sometimes pausing/playing desyncs. Try to test to see why. Seems to happen after a new video is added.
* The serverstate is set to seeking, and then it seems that state is never undone, so alignstatewithserver is never able to fire again no matter what happens, and the play button stops working because it doesn't do anything unless the state is playing, paused, or unstarted. So there's an issue somewhere with the state being left in an unworkable situation
    ** I think it's because I was not checking the pings on the vieweridlist, and also on the client side I hadn't been setting the user ID properly. So a page frefresh instantly gave you a new user ID, and then your old one wasn't being removed from the server ID list. This caused play button to stop working because its code doesn't check for the "seeking" state.
* When you refresh the page, it starts playing immediately without triggering an event for the other player. Likely because autoplay is on. Disable autoplay in the player options.

====

12/6/20

(EXTRA):
    * Fixed an issue that was causing new videos to not be added when you entered the URL in the search bar.
* Hot-joining while the video was paused didn't work, but now it seems fixed.
    ** Actually it still doesn't work if you're doing it from a newly-added video. So I added some console logs to the alignstatewithserver shit.
    ** Had an issue where we weren't setting the videoTime to the serverTime when adding it in, which we need to do specifically if a user is hot-joining and the universal video state is not playing.

====
12/5/20

* Add the popup modal that watch2gether has when a page is restarted.
*(EXTRA):
    ** fixed serverlist so it updates as soon as someone drops out
    ** Fixed time alignment. Now if you're not within 5 seconds of the server time, you're skipped to it.
    ** Fixed it so when you hot-join the room, your video is aligned with the state
    ** Pinging the seekingID and viewerID's now.
* In order for dropping in/out to work, we need a modal to pop up when you open the page that says "Join room"
* Fix the code to ping ID's in videowatcher and seekingID. Also make it so as soon as you come in, if you click somewhere, the pinginterval starts and you get lined up with everyone else's video state. Shouldb e able to drop in/drop out.
* Add code that pings the videowatcher and seekingID lists, same as pingName. When people DC while still in the seeking list, it breaks.
======
12/4/20

** captions
    *** Users have to press a button, then it will reload the video with the current time and captions enabled.
* What's going on with the volume??? It's too low.
    **Seems like that's about as loud as it gets.

=====
12/3/20

* "ServerList is initialized!" message is printed 2x at once. Why?
* Make scrubbing work
    * Seek
    * Set our own state to seeking
    * Send the "SEEKING" state to server
    * Tell server to set seeking on other clients
        1. When player sets state to seeking, save the current universal state as a previousState val.
        2. Now store all active ID's in a seeking array
        3. When a client checks in, if the universal state is seeking, and their ID is in the array, set their state to seeking, and send them to the seeking time.
        4. When the client checks in again, if the state is still seeking, and their ID is in the array, but their time is within the buffer, remove them from the seeking array and set their state to previous state.
            ** This buffer is different from the buffer we'll use on the client. On the client, we'll always be checking to see if we're behind by x amount of seconds. If so, jump ahead. But not if we're ahead already. Don't check for that. This client-side buffer is merely for keeping things synced. The serverside buffer is for allowing for margins of error when checking if we've seeked properly, because sometimes buffering can happen.
        5. After every removal, check if the array is empty. If so, set the universal state to the previous state.
    * Save the seek time on the server
    * When client checks state, if it's seeking, and it's outside our safety buffer, then seek to that time. After it's done, set local state to whatever it was prior to the seeking coming in.
** Make pressing play play the videos of the other users
    x Maybe make it so when you send state by triggering an event, the server saves the user ID
    x Idea is, whenever client-state-changed is accessed, if anything is changed, set a server-side boolean to true and then attach the userID to it. When you then ping the server's video-state, if your ID does not match the stored ID, you have to change. If it does, you don't.

====
12/2/20

* Do the same for adding a new video
====
* Make clicking on the progress bar work (scrubbing/seeking through video)
* Write server-side code so playing/pausing on one side plays/pauses on the other
* Create code that loads a default video for when no video has been added.
    ** This will have to be code on the actual page.
* Change the way messageID's are generated. Generate them in the server, still, but make them random numbers (or strings) rather than sequential. This will take a deep rewrite. Lots of the code is designed assuming message_id will be an int. For example, seenArray[] etc.
* Add a function that occurs at an interval (on the server). Its job is to shrink down the takenNames array, possibly by creating a copy that takes only the non-null entries. Then rename that copy to takenNames and be done with the old array. Save memory.
* Blocking name copying should account for case.
* Make it so that when you come into the page with a cookie, it doesn't set the name field to empty, because you do already have a name probably.
* Refreshing the page does not remove the username from the list. Will have to use a cookie to do that. (Closing the browser does work) [But it does work on chrome and similar browsers. So you just need to implement the existing solution in a way that's browser-independent]
    ** Write code so that if your ID saved in your cookie is also stored in the names list, it deletes that name from the server. But this would only make it so a name gets released when the person comes back.
    ** You're just gonnna have to write separate code based on what browser it is, honestly.
    ** https://developer.mozilla.org/en-US/docs/Web/API/PerformanceNavigationTiming/type#Browser_compatibility
    ** https://stackoverflow.com/questions/5004978/check-if-page-gets-reloaded-or-refreshed-in-javascript/53307588#53307588
    ** Every time a user pings the server, change a value. On the server side, check if that value has changed in the last x seconds. If no, change the status on the server list to some kind of "connection lost" situation. Check another 2 times. If still nothing, drop them from the server list because they've DC'd.
        *** Could also still run code for removing user from list if they close tab, just, if that doesn't work, the server-side stuff goes into action.
    ** The issue now is if you're idle for a long enough time, your ping fails and your name is deleted. But if you talk, you're good. It's a problem in the scripts.js
    ** SOLVED: I made the client side ping the server at a certain interval. The serverside checks every so often if it has gotten pinged, and if not, it DC's the users.
* Make it add people to the serverlist as soon as they log in, not when they send a message.
    ** That's done! But now that name is not updated when you change your name. It's stored in takenNames but it's not treated like it's the user's takenName.
* Consider changing the fact that it pastes the entirety of the chat history when you load in.
* Anon names don't show up in the server list, unless you change to your anon-name FROM a specified name. If you simply enter the chat and enter a message, anon-name does not go into the server list. This implies that when you change your name back to anon, it's getting entered into the takenNames array.
    ** It may be required to put the AnonNames back into the takenNames array. Let them be added. Just on the client side, stop people from spoofing anon names and we should be fine.
* Make the message entry field go to a new line, or pop out/expand when the text exceeds a certain amount of words. ((May need to leave this for when you're putting the final touches on the UI.))[[For now it's a textarea, so it's fine]]
* For some reason when the "error choose a new name" message is sent, it jumps you to the top of the chat? Fix that [[Current fix is that scrollTop() is set to element.height() * seenArray.length. Likely any refactoring that eliminates SeenArray will destroy this solution.]]
* Make it so people can't have the same name.
* If the message is too long, it gets cut off to the last parts of it. Fix that.
* For some reason the chatrooms connecting from the outside seem to stop being able to send messages, until they receive a new message.
* Another glitch: Every time a user submits a message, it submits for EVERYONE in the chatroom.
* TakenNames is still broke. Still. Right now because if(canUseName) calls addToTakenNames and creates a new userlist, literally every time you send a message your name is being added to the list, which of course breaks the point. [Should be fixed now]
* Add a serverlist, with everyone currently logged in. This is basically going to be a smaller version of the chat table. Whenever a user changes their name, change it (but in parenthises, put their userID)
    ** As of now, for some reason it keeps infinitely adding to the list. Also if I try to check for the existence of "response.name" prior to adding stuff to the list, it stops working altogether. Also none of the text is actually visible in the userlist.
    ** Have to set an interval, then do a get request to the server seeking a list of all users, then just update the list with new names.
    ** Should be able to just use takenNames. But if I do, that means I must undo the code that blocks the Anon names from being stored there, since they must appear in order to be listed.
    ** This is the plan. Just cycle through the whole thing, add them to an empty local array, pass that local array. On scripts side, check if the array length is greater than 0. IF so, there's something there. Add it to the list table. Create a new separate variable in the server side. A random number. Give it a new value every time a name is pushed into taken names. Set the userlist array that we're sending to the client to have its own property, which equals that randomly generated number. That way every time we send the array, we can check that number, and if it's changed, then we can update the user list.
    ** You also gotta erase the existing list in the HTML and repopulate it every single time.
    ** Now just fix takenNames, because that still, STILL is buggy and fucked.
*Shrink the height of the chat to make space for an expanding text input field. [Or just make the text input field float above everything when the message exceeds a certain length.]{{Ended up just switching the message input field to a textarea. Will fix the frontend stuff later. Focus on backend for now.}}
* Why does the first message start one spot below the top? Fix it.
* Add max amount size for username in client-side JS code.
* Put the name field above the message entry field
* Change it so you never add or remove the ANON names on the server, because they're protected on the client side.
* Names are not being released when the user closes the browser (disconnects). Have to learn how to code that interaction. Probably need to set a timer, and if a certain username hasn't been used since that last ping, release it. Or maybe it's time to just set up a database. Probably send a cookie to the browser containing their userID so when they come back they have the name. [Ended up just setting code that hits the server when the user closes the window.]
* Timestamps show the time of the person sending the message. Make it consistently convert all timestamps to that of the client, so it always looks the same.
* Consider sending an object containing two objects: 1) The message object and 2) the username+userid object. This allows me to verify the username in the same function as the message is sent, so I'm not making 2 requests to the server for every 1 message.
* Block a user's ability to steal someone's anonName, on the client side.
* As it stands, if you change your name to one that is already taken, and then send a message, does it release the name you tried to change away from? It should. I've already set it to clear the value of #name-input if the server denies your name, so the user is safe there.
* New glitch: When you change your name, for some reason it makes the previous user's name available, defeating the purpose of storing the names. It's possible that when user A posts a message, their name is getting stored in nameToRelease. So when user B changes his name and posts a message, A's name is getting released instead. Make sure the nameToRelease var is not being touched if the name hasn't been changed.
* New Glitch: Messages don't show across clients anymore. Look into the code you just added that catches and releases names so there aren't two of the same person.
* Make it so people can't have the same name.
    + Currently it saves your name and doesn't let others use it, but it doesn't release the name once you change your name again. For example: Your name is John, you send a message, you change it to Beth, you send a message, people should be able to have John now.
* Change it so the name changes as soon as you type it out, rather than after you hit "return." For mobile users.
* Remove "enter name" field from the chat table. It scrolls out of view as new messages are added.
DOING:
* Add playing from other sites
    * (1/12) Working on Vimeo.
        * Right now if I use the loadPlayerScripts code to load in the vimeo code, everything works very well. So we're going to do that. Every time there's a new player added, load in that script code. We have to refactor at this point, because it's such a mess that I'm not even clear on which functions exist or don't already. But I have validated that vimeo works. At least on desktop.
    * (1/13) So I've started building out the OOP rendition of the code. It creates more work for infrastructure, but allows the code in the main script file to be way more concise. Also allows me to put all code that's relevant to each other together in their own files.
        * Coming back to it tomorrow, I want to finish building the vimeo player class out. Once I've got that done, it's on to the youtube player. With those both done, I'll have a very nice basis for my code where I can build out to implementing the last few, and then I'll finally implement the code for extracting videos through youtubedl.
    * (1/14) Finished fully reshaping how the underlying code works. Now I just need to reshape how data is sent over sockets, and finish implementing vimeo. Then it will be on to youtube, which will clean up SO MUCH code. From there I can implement the others before turning toward the youtubedl stuff. That will essentially put the most basic version of the site to rest, at which point I can finalize backend stuff and then do the UI.

*THOUGHTS:

**MOST IMPORTANT TODO**
* Add your own recommended videos overlay when video is paused.
* Fix up the chat.
* Give rooms logos. Would be cool.

TODO:
* Add a search button to the searchbar. Also detach it from the videocontainer so it's its own thing.
* Change from buttons to a tags so they don't do that weird press animation anymore.
* Gotta implement a different session store from the default.
    ** https://github.com/expressjs/session#compatible-session-stores
* Try to use ejs layouts.
* Add an overlay over the room that says "PLEASE REFRESH THE PAGE, but disappears if you press join room. This way, the join room modal always happens. No idea why tf it's not always popping up now.
* Why does it say someone tried to join a room that didn't exist when you get '/'?
* Consider deleted the rooms array and having all code interface directly with the DB, nothing saved in local storage.
* When host leaves a room and it becomes empty, it reverts to a default state. Shouldn't do that.
* Swap out most buttons for divs. Divs don't give that weird shifting animation buttons automatically do.
* Make room passwords work. Require new entrants to enter the password if they want to actually execute the joinRoom code. Perhaps have a password prompt replace the joinButton interface.
* If you can, add video length to the info on the search results.
* For some reason the playback rate initializes as undefined in the html. Probably because of the initialization code when hotjoining.
* Add a "re-align" button so if things get unaligned, just press that, boom. trigger the sendstate event
* Fix the search so that if you return a number of results x that x % 4 != 0, then you insert 4 minus that amount of results. Such as, 21 results, 21 % 4 = 1, insert 4 - 1 results, meaning 3 fake results, so the results list balances out. Otherwise figure out how to make everything justify to the left rather than space out evenly.
* Now just have to test everything thoroughly. All features.
* Change the chat so it's ways floating
* Show text to say who put in a video/pressed play/etc
* When a yt video is played, search youtube for that video title or the uploader. Then in recommendeds, show the results.
* Change icon to replay icon when video ended
* Implement a history
* Improve search with ytsr
    https://github.com/TimeForANinja/node-ytsr/blob/master/README.md
* When a video pauses or ends, above the recommended videos, show tips like "Press the reconnect button to re-align all the videos."
* Add recommended videos overlay over the video when it reaches ended/paused status, with your own videos in that the viewer can click and add instantly.
* In the description/title search results on the server, check for the html codes like &quot; etc, and convert them over to their actual characters.
* Full screen doesn't work in chrome again. Goddammit. The video controls look janky and don't go away.
    ** Probably have to put the css in a -webkit thing
* REFACTOR/CLEAN UP CODE/ORGANIZE FOLDERS


* Stretch goal: Let users paste embed codes of any video player <iframe>, then play it in our video container div.
* Write code that tries to play a video on any site by seeking out the most common tags that hold videos. Maybe grab the mp4 links directly and load those up into a video tag? The code should try as many tactics as possible until it succeeds. Maybe even have a way to ask the viewer "Is this the video? If no, we'll try to find it in the link again. Is this the video?" This requires web scraping.
* Write

===
* Add private messaging functionality
    ** Have to create tabs within the webpage, one for each chat that's open (general, privatechat1, privatechat2, etc). The tabs exist above the chat. In private chats, the serverlist lists everyone included in the private chat.
* Add the ability to @ someone. (I have implemented very rudimentary code for this.)
* Once all above is instituted, do refactoring. Clean up the code. Once that's done, make simultaneous youtube videos work. Once that's done, set up the database. Once that's done, do the frontend so it looks nice using just css and html5 animations etc.

REFACTORING:

* Maybe add all buttons to an array with their names as the indices. Would allow for cycling through them to add the enlarged classes.
* Put the join-room-button code in the actual index.html, in a script in the head, so it runs before the rest of the page loads; otherwise people are able to click on things before the overlay loads to block mouse events.
* Split chat code and video code into separate JS files
* Get rid of clientYTPlayer util class and have literal instantiated objects. Use polymorphism to handle different video types (as in, youtube vs not youtube)
* Remove Jquery
* Write a clientytplayer function that is passed a state and sets current state to that, previous state to whatever it was before, as well as makes 
* In IsNameAvailable(), change the for loop to something cleaner.
* Set up something similar to: https://stackoverflow.com/questions/36327702/nodejs-express-getting-error-as-referenceerror-bodyparser-is-not-defined

THOUGHTS:

* Use web-scraping to get better search results than the youtube search API might give you. That way you'll do better than watch2gether's search.
* Default video should be a 1-minute explanation of what the site is and how it works.
* When done with this whole list, refactor the code before proceeding with the next phase of development.
* This will ultimately be a watch2gether clone. I think it's possible to do by having the client catch when the user changes the time on the embeded video, then send that new set time to the server, then send that to the other viewers' clients.
* Add error handling. For example, currently (11/8/20), if your name for some reason is never released after you choose a new one, the code has no way of recognizing that issue. That's a serious issue because the name can never be used again, even by you.
* Could make it so it stores the status of videos. So when you put in a new video, you can press a "back" button that reverts to the previous video at the time that it was at.
* Consider what to do about buffering. I guess just ignore it? It's kinda handled by the time buffer and everything.
    ** Probably if it's buffering, the client shouldn't ping the video state, because we kinda need to wait until it's done.
    ** in the onplayerstatechange callback, check if the event triggered is buffering. If so, set our state to buffering. If the event is not buffering, check if our state is buffering--if so, set our state to whatever the event is. This way, we only take the state this callback gives us if we were just buffering; otherwise we ignore it.
* Big scary thing is how much the youtube API is still checking for me. Like after it seeks, even though it was just playing, it might pause locally. That would not trigger an event on the server. Theoretically, if I seek while playing, the server remembers we were just playing, and when I'm done seeking, it sets me back to playing no matter what. But if I'm still buffering and the server tries to make me play, youtube API might reject the playVideo() call and leave me buffering. What then? I'm left to my fate, because my clientYTPlayer.currentState is still == PLAYING, but I'm not playing.

* SCRAPPED:
* Load player from JS--not on the index.html page. Gives us so much more ability to do things when the video first loads. Can't just move the script tag in the html down below our other scrips, because they expect player to be a thing. Then agai*n a lot of that code is in the document.onReadystate stuff, which runs after the page is already loaded, including the JS in the html.
    ** This won't work. Instead, start the page with an HTML5 video just like watch2gether. A user can then create a player when they search and play a video.

~~~~~~~~~~~
DONE
===========
~~~~~~~~~~~

1/11/21

* Add livestream functionality
    * livestreaming already basically works...
    * I've decided it's not necessary.
* Add user account abilities.
    * Gotta have user auth
    * Encrypted passwords
    * Add yt playlist functionality

======

1/8/21
* Add play history
    ** History implemented server-side. Just have to show it on the room page as a popup.
* Create database to save room info.
* Host ID is undefined. That tells me that we're not setting host ID to new people. Likely because we're no longer filtering the array when people leave.
    *"Someone tired to enter a room that didn't exist" happens when 
* Code for leaving a room doesn't work. Issue is, we only have the socket.id to work with, so we have to find the room based on that alone. Will be a little frustrating.
* Rooms don't initialize when you join them anymore.
* Seems like a lot is broken. If you try to enter a room via direct link, it doesn't actually send you there. It's just broken.
* Make room list in index look a little better so we can actually work with it.
* Have host update info about the room state when they press play or pause. This includes the id, thumbnail, etc.
* Convert everything in server over from the locally saved rooms array to using the DB.

=======

1/7/21

* Return to rooms based on cookies
    ** Check if you can do an ajax call as soon as roomID is set. It's a get request. On server side, if the id passed through the request is the id of any room, res.redirect to that room.
    * Can't intelligently do this.
    * Instead, create an index page that has a list of all public rooms (rooms start private by default)
        * You can join any room, or just create your own.
* Add ability to change room name separate from room ID.
    ** Basically no rooms can be anything but a uuid or name+uuid.
        * Adjust how the routes work so this is the case.
        * Generate random name when room is first made, if one not provided
    ** Have to change room generation so all rooms have their custom uuid.
    ** Do like w2g and append the room name to the front of the uuid
* Ability to add room details:
    * name,
    * thumbnail
    * nsfw: true/false
        ** This automatically flicks to true if not watching youtube.
    * description

===

1/6/21

* Adjust some minor issues
    * ADD THE SYNC BUTTON SO USERS CAN SYNC MANUALLY.
* When host presses play or pause, send their time. If their time is > or < 5 seconds, jump other users to their time.
* Gotta fix the joinroom code because it's not coded properly. Assumes we're using objects when we're using arrays.
    ** When video is initalized, it's not seeking to the proper time. Everything else seems to work for hotjoining.
    ** That's all fixed, but it seems the host is not being swapped out when people leave the room.
    ** All fixed.
    * There needs to be a room "host" whose video state is "THE" video state. Add functionality to both manage the hosts so if one person disconnects, someone else becomes the host is needed, as well as creating a host when room is empty, and manually switching who the host is if the users so desire.

* Set up rooms
    ** Now rooms work in the basic sense. Hotjoining too.
    ** But hot-joining code is extremely janky. Write something that saves the info relative to the individual rooms, like counting how many people are in each room. Also find out how to check when someone DC's from the room.
    ** To set up room-joining code, make an array of rooms that contains objects. When a new room is joined, check if that room already exists. If not, create that room in the array. Use the room name as the key in the index.
        The room will be an object that holds:
        {
            users: { localName, serverName, userID, isHost, pfp },
            host, //holds userID of host
            videoID, //holds id most recently played video
            videoTime, //most recent video time,
            messages: [
                        {
                            mID, mContent, mUserID, mlocalName, mlocalTimeStamp, mUniversalTimeStamp
                        }
                    ]
        };

=====
1/5/21
* Set up rooms
    * Got the basics of it working. Just gotta set it up so when you join a room, it actually aligns your state with the state of the others.

====
1/4/21
* Set up the VS tools and improvements I learned about over the break. Come up with plan of attack to finish this project by the end of the month.
* Confused about how to initialize a video that hotjoins with websockets.

===
12/15/20


* Pressing CC while it's paused will make it play and make the play/pause button show a play button, even though the video is playing (should show pause whenever video is playing).
    ** Fixed. Had to pause video after initing it if state is paused.
* Now pasting links doesn't work anymore. It just searches it for some reason.
    ** Fixed. It was a logic error.
* For some reason adding code to the update tooltip code that actually shows hours (instead of 87 minutes, 100 minutes etc) has broken the ability of the progress bar to skip past 60 minutes/hour, or to even update past that value. This is extra strange because the progress bar isn't full when it stops, so it's clearly initialized properly. Just when it's time to update again, if it's past 60 minutes, it won't anymore. Strange.
    *Done. It was a typo.

====
12/12/20


* Should just set it to put in inline-flexes for every row. Count it off. Every 3 items, put in a new row. (But this solution isn't scaleable to smaller screens)
    SEems to work now. Just had to fuck with the flexbox settings.
* clicking a search result doesn't send the new video to the other clients. Might have to do with the origin var.
    ** It was actually the fact that extractID now returns null if the url entered is already in ID form. So we had to change it so when alignstatewithserver gets a new URL sent to it, it sets clienturl to the serverurl without extracting an ID. This is fine, because by the time an ID hits the server, it's already been extracted.

====
12/10/20

* everytime you search, set an interval that checks the server for our search result. If we don't find it after 3 tries, give up and put out some error code. But we need to associate an id with each search result, so that when we check for a search result we know we're getting what was meant for us. This'll allow clients to search simultaneously. When you finally get a result back, clear the interval.
=====
DONE:
12/9/20

* For fixing the seekingID ping issue, we should setTimeOut() every time we go through the loop and we're done seeking and the others aren't. If we haven't cleared the seekingIDlist by then, clear everyone in there out and delete their viewerid too.
    ** Actually I just increased the ping time. It was going too fast.
* Why does the bar jump back and forth if you hot-join while the video is paused and then seek?
*Hot-joining while video paused, then seeking immediately was glitchy. Time would jump back and forth between what it was when we joined and what it is now that we seeked. Fixed it.
    *maybe I should change updateYTVideoTime to not do anything if state is paused.
        **This was the problem.

* clicking the fullscreen button doesn't let you out sometimes

===
12/8/20
** Make it save all the options in a cookie, so when you reload the page you're good to go.
    ** CC
    ** looping
    ** playbackRate
        **This one didn't make as much sense in practice, so I cut it.
* Make play button replay hte video if state is ended. 
* Ultimately wrap the youtube div in another div, and create your own controls. That way when the user wants to watch a vid from another site, you just fill that div with their video player.
* Set up other youtube functions (captions, etc)
    ** Set up the buffering bar using the getPlayerLoadedFraction() function
    
* Catch the play/pause events from users clicking on the player
    **This still has to be considered for mobile probably. Not sure if pointer-events:none works on mobile.

    ** Catch the spacebar so it plays video (but not if I'm typing in chat)
    ** Loop button so it can loop
        *** First should set a bool to true so when the video state changes to "ENDED," we set the universal time to 0 and then change the universal state to PLAYING. Boom. Loop.
        *** Don't think I should let youtube's player handle the looping.
* Still need to write code that actually loops the video when its state changes to ended.
*Clicking the screen in fullscreen mode should toggle the controls on. If you click and toggle them on, they can't be toggled off by anything but moving the mouse out of the controls.

=====
12/7/20
    ** Full screen controls that show up at the bottom of the screen and drop down after x amount of time
    ** Playback rate
        *** Just check in align server state if the playback rate is different from the server's. If so, adjust ours. When you adjust playback rate, set it on the server with sendstate.
* Set it so if you click the playbackrate button while in fullscreen, it just toggles to the next value up or down. Either do that, or add fastforward and rewind buttons on either side of the playbackrate, and disable playbackrate while inFullScreen is true.
* Catch the esc keypress and check if inFullScreen is true. If so, set it to false.
* Video controls now appear in full screen mode, godfuckingdammit. TOOK. HOURS. Even watch2gether doesn't do that

====
12/6/20

*We're setting playbackrate on our end. Now we just need to set it to the universal value in the server, and then in alignwithstate adjust playbackrate to match the server's.
* Also sometimes pausing/playing desyncs. Try to test to see why. Seems to happen after a new video is added.
* The serverstate is set to seeking, and then it seems that state is never undone, so alignstatewithserver is never able to fire again no matter what happens, and the play button stops working because it doesn't do anything unless the state is playing, paused, or unstarted. So there's an issue somewhere with the state being left in an unworkable situation
    ** I think it's because I was not checking the pings on the vieweridlist, and also on the client side I hadn't been setting the user ID properly. So a page frefresh instantly gave you a new user ID, and then your old one wasn't being removed from the server ID list. This caused play button to stop working because its code doesn't check for the "seeking" state.
* When you refresh the page, it starts playing immediately without triggering an event for the other player. Likely because autoplay is on. Disable autoplay in the player options.

====

12/6/20

(EXTRA):
    * Fixed an issue that was causing new videos to not be added when you entered the URL in the search bar.
* Hot-joining while the video was paused didn't work, but now it seems fixed.
    ** Actually it still doesn't work if you're doing it from a newly-added video. So I added some console logs to the alignstatewithserver shit.
    ** Had an issue where we weren't setting the videoTime to the serverTime when adding it in, which we need to do specifically if a user is hot-joining and the universal video state is not playing.

====
12/5/20

* Add the popup modal that watch2gether has when a page is restarted.
*(EXTRA):
    ** fixed serverlist so it updates as soon as someone drops out
    ** Fixed time alignment. Now if you're not within 5 seconds of the server time, you're skipped to it.
    ** Fixed it so when you hot-join the room, your video is aligned with the state
    ** Pinging the seekingID and viewerID's now.
* In order for dropping in/out to work, we need a modal to pop up when you open the page that says "Join room"
* Fix the code to ping ID's in videowatcher and seekingID. Also make it so as soon as you come in, if you click somewhere, the pinginterval starts and you get lined up with everyone else's video state. Shouldb e able to drop in/drop out.
* Add code that pings the videowatcher and seekingID lists, same as pingName. When people DC while still in the seeking list, it breaks.
======
12/4/20

** captions
    *** Users have to press a button, then it will reload the video with the current time and captions enabled.
* What's going on with the volume??? It's too low.
    **Seems like that's about as loud as it gets.

=====
12/3/20

* "ServerList is initialized!" message is printed 2x at once. Why?
* Make scrubbing work
    * Seek
    * Set our own state to seeking
    * Send the "SEEKING" state to server
    * Tell server to set seeking on other clients
        1. When player sets state to seeking, save the current universal state as a previousState val.
        2. Now store all active ID's in a seeking array
        3. When a client checks in, if the universal state is seeking, and their ID is in the array, set their state to seeking, and send them to the seeking time.
        4. When the client checks in again, if the state is still seeking, and their ID is in the array, but their time is within the buffer, remove them from the seeking array and set their state to previous state.
            ** This buffer is different from the buffer we'll use on the client. On the client, we'll always be checking to see if we're behind by x amount of seconds. If so, jump ahead. But not if we're ahead already. Don't check for that. This client-side buffer is merely for keeping things synced. The serverside buffer is for allowing for margins of error when checking if we've seeked properly, because sometimes buffering can happen.
        5. After every removal, check if the array is empty. If so, set the universal state to the previous state.
    * Save the seek time on the server
    * When client checks state, if it's seeking, and it's outside our safety buffer, then seek to that time. After it's done, set local state to whatever it was prior to the seeking coming in.
** Make pressing play play the videos of the other users
    x Maybe make it so when you send state by triggering an event, the server saves the user ID
    x Idea is, whenever client-state-changed is accessed, if anything is changed, set a server-side boolean to true and then attach the userID to it. When you then ping the server's video-state, if your ID does not match the stored ID, you have to change. If it does, you don't.

====
12/2/20

* Do the same for adding a new video
====
* Make clicking on the progress bar work (scrubbing/seeking through video)
* Write server-side code so playing/pausing on one side plays/pauses on the other
* Create code that loads a default video for when no video has been added.
    ** This will have to be code on the actual page.
* Change the way messageID's are generated. Generate them in the server, still, but make them random numbers (or strings) rather than sequential. This will take a deep rewrite. Lots of the code is designed assuming message_id will be an int. For example, seenArray[] etc.
* Add a function that occurs at an interval (on the server). Its job is to shrink down the takenNames array, possibly by creating a copy that takes only the non-null entries. Then rename that copy to takenNames and be done with the old array. Save memory.
* Blocking name copying should account for case.
* Make it so that when you come into the page with a cookie, it doesn't set the name field to empty, because you do already have a name probably.
* Refreshing the page does not remove the username from the list. Will have to use a cookie to do that. (Closing the browser does work) [But it does work on chrome and similar browsers. So you just need to implement the existing solution in a way that's browser-independent]
    ** Write code so that if your ID saved in your cookie is also stored in the names list, it deletes that name from the server. But this would only make it so a name gets released when the person comes back.
    ** You're just gonnna have to write separate code based on what browser it is, honestly.
    ** https://developer.mozilla.org/en-US/docs/Web/API/PerformanceNavigationTiming/type#Browser_compatibility
    ** https://stackoverflow.com/questions/5004978/check-if-page-gets-reloaded-or-refreshed-in-javascript/53307588#53307588
    ** Every time a user pings the server, change a value. On the server side, check if that value has changed in the last x seconds. If no, change the status on the server list to some kind of "connection lost" situation. Check another 2 times. If still nothing, drop them from the server list because they've DC'd.
        *** Could also still run code for removing user from list if they close tab, just, if that doesn't work, the server-side stuff goes into action.
    ** The issue now is if you're idle for a long enough time, your ping fails and your name is deleted. But if you talk, you're good. It's a problem in the scripts.js
    ** SOLVED: I made the client side ping the server at a certain interval. The serverside checks every so often if it has gotten pinged, and if not, it DC's the users.
* Make it add people to the serverlist as soon as they log in, not when they send a message.
    ** That's done! But now that name is not updated when you change your name. It's stored in takenNames but it's not treated like it's the user's takenName.
* Consider changing the fact that it pastes the entirety of the chat history when you load in.
* Anon names don't show up in the server list, unless you change to your anon-name FROM a specified name. If you simply enter the chat and enter a message, anon-name does not go into the server list. This implies that when you change your name back to anon, it's getting entered into the takenNames array.
    ** It may be required to put the AnonNames back into the takenNames array. Let them be added. Just on the client side, stop people from spoofing anon names and we should be fine.
* Make the message entry field go to a new line, or pop out/expand when the text exceeds a certain amount of words. ((May need to leave this for when you're putting the final touches on the UI.))[[For now it's a textarea, so it's fine]]
* For some reason when the "error choose a new name" message is sent, it jumps you to the top of the chat? Fix that [[Current fix is that scrollTop() is set to element.height() * seenArray.length. Likely any refactoring that eliminates SeenArray will destroy this solution.]]
* Make it so people can't have the same name.
* If the message is too long, it gets cut off to the last parts of it. Fix that.
* For some reason the chatrooms connecting from the outside seem to stop being able to send messages, until they receive a new message.
* Another glitch: Every time a user submits a message, it submits for EVERYONE in the chatroom.
* TakenNames is still broke. Still. Right now because if(canUseName) calls addToTakenNames and creates a new userlist, literally every time you send a message your name is being added to the list, which of course breaks the point. [Should be fixed now]
* Add a serverlist, with everyone currently logged in. This is basically going to be a smaller version of the chat table. Whenever a user changes their name, change it (but in parenthises, put their userID)
    ** As of now, for some reason it keeps infinitely adding to the list. Also if I try to check for the existence of "response.name" prior to adding stuff to the list, it stops working altogether. Also none of the text is actually visible in the userlist.
    ** Have to set an interval, then do a get request to the server seeking a list of all users, then just update the list with new names.
    ** Should be able to just use takenNames. But if I do, that means I must undo the code that blocks the Anon names from being stored there, since they must appear in order to be listed.
    ** This is the plan. Just cycle through the whole thing, add them to an empty local array, pass that local array. On scripts side, check if the array length is greater than 0. IF so, there's something there. Add it to the list table. Create a new separate variable in the server side. A random number. Give it a new value every time a name is pushed into taken names. Set the userlist array that we're sending to the client to have its own property, which equals that randomly generated number. That way every time we send the array, we can check that number, and if it's changed, then we can update the user list.
    ** You also gotta erase the existing list in the HTML and repopulate it every single time.
    ** Now just fix takenNames, because that still, STILL is buggy and fucked.
*Shrink the height of the chat to make space for an expanding text input field. [Or just make the text input field float above everything when the message exceeds a certain length.]{{Ended up just switching the message input field to a textarea. Will fix the frontend stuff later. Focus on backend for now.}}
* Why does the first message start one spot below the top? Fix it.
* Add max amount size for username in client-side JS code.
* Put the name field above the message entry field
* Change it so you never add or remove the ANON names on the server, because they're protected on the client side.
* Names are not being released when the user closes the browser (disconnects). Have to learn how to code that interaction. Probably need to set a timer, and if a certain username hasn't been used since that last ping, release it. Or maybe it's time to just set up a database. Probably send a cookie to the browser containing their userID so when they come back they have the name. [Ended up just setting code that hits the server when the user closes the window.]
* Timestamps show the time of the person sending the message. Make it consistently convert all timestamps to that of the client, so it always looks the same.
* Consider sending an object containing two objects: 1) The message object and 2) the username+userid object. This allows me to verify the username in the same function as the message is sent, so I'm not making 2 requests to the server for every 1 message.
* Block a user's ability to steal someone's anonName, on the client side.
* As it stands, if you change your name to one that is already taken, and then send a message, does it release the name you tried to change away from? It should. I've already set it to clear the value of #name-input if the server denies your name, so the user is safe there.
* New glitch: When you change your name, for some reason it makes the previous user's name available, defeating the purpose of storing the names. It's possible that when user A posts a message, their name is getting stored in nameToRelease. So when user B changes his name and posts a message, A's name is getting released instead. Make sure the nameToRelease var is not being touched if the name hasn't been changed.
* New Glitch: Messages don't show across clients anymore. Look into the code you just added that catches and releases names so there aren't two of the same person.
* Make it so people can't have the same name.
    + Currently it saves your name and doesn't let others use it, but it doesn't release the name once you change your name again. For example: Your name is John, you send a message, you change it to Beth, you send a message, people should be able to have John now.
* Change it so the name changes as soon as you type it out, rather than after you hit "return." For mobile users.
* Remove "enter name" field from the chat table. It scrolls out of view as new messages are added.